import {Builder} from '@logi/base/ts/common/builder'
import {Impl} from '@logi/base/ts/common/mapped_types'
import {
    ViewPart,
    ViewPartBuilder,
    ViewType,
} from '@logi/src/lib/intellisense/editor/display'
import {
    Candidate,
    CandidateGroup,
    Filter,
} from '@logi/src/lib/intellisense/suggest'
import {getResolvedNode, ResolvedNode} from '@logi/src/lib/intellisense/utils'

export interface PanelStatus {
    /**
     * The data of the panel.
     */
    readonly page: readonly PanelUnit[]
    /**
     * The index of the item currently the user focus on.
     */
    readonly selected: number
    /**
     * Whether the new panel generated by selecting candidate.
     */
    readonly processed: boolean
    reset(): void
    addData(groups: readonly CandidateGroup[]): void
    getSelectedUnit(selected?: number): PanelUnit
}

class PanelStatusImpl implements Impl<PanelStatus> {
    public page: readonly PanelUnit[] = []

    public selected = -1
    public processed = false

    public reset(): void {
        this.page = []
        this.selected = -1
        this.processed = false
    }

    public addData(groups: readonly CandidateGroup[]): void {
        if (groups.length === 0) {
            this.reset()
            return
        }
        const page = convertPage(groups)
        this.page = page
        this.selected = page.length > 0 ? 0 : -1
        return
    }

    public getSelectedUnit(selected = this.selected): PanelUnit {
        let idx = selected
        if (idx < 0)
            idx = 0
        else if (idx > this.page.length - 1)
            idx = this.page.length - 1
        return this.page[idx]
    }
}

export class PanelStatusBuilder extends Builder<PanelStatus, PanelStatusImpl> {
    public constructor(obj?: Readonly<PanelStatus>) {
        const impl = new PanelStatusImpl()
        if (obj)
            PanelStatusBuilder.shallowCopy(impl, obj)
        super(impl)
    }

    public page(page: readonly PanelUnit[]): this {
        this.getImpl().page = page
        return this
    }

    public selected(selected: number): this {
        this.getImpl().selected = selected
        return this
    }

    public processed(processed: boolean): this {
        this.getImpl().processed = processed
        return this
    }
}

export function isStatus(obj: unknown): obj is PanelStatus {
    return obj instanceof PanelStatusImpl
}

export interface PanelUnit {
    readonly parts: readonly ViewPart[]
    readonly entity: Readonly<Candidate> | readonly Filter[]
    readonly nodeMsg?: ResolvedNode
}

class PanelUnitImpl implements Impl<PanelUnit> {
    public parts: readonly ViewPart[] = []
    public entity!: Readonly<Candidate> | readonly Filter[]
    public nodeMsg?: ResolvedNode
}

export class PanelUnitBuilder extends Builder<PanelUnit, PanelUnitImpl> {
    public constructor(obj?: Readonly<PanelUnit>) {
        const impl = new PanelUnitImpl()
        if (obj)
            PanelUnitBuilder.shallowCopy(impl, obj)
        super(impl)
    }

    public parts(part: readonly ViewPart[]): this {
        this.getImpl().parts = part
        return this
    }

    public entity(entity: Readonly<Candidate> | readonly Filter[]): this {
        this.getImpl().entity = entity
        return this
    }

    public nodeMsg(node: ResolvedNode): this {
        this.getImpl().nodeMsg = node
        return this
    }
}

export function isPanelUnit(obj: unknown): obj is PanelUnit {
    return obj instanceof PanelUnitImpl
}

/**
 * Convert the intellisense result to the data of the panel.
 */
export function convertPage(
    groups: readonly CandidateGroup[],
): readonly PanelUnit[] {
    const units: PanelUnit[] = []
    groups.forEach((g: CandidateGroup): void => {
        if (g.members.length === 1) {
            const builder = new PanelUnitBuilder()
                .parts(g.members[0].view)
                .entity(g.members[0])
            const n = g.members[0].handle?.nodes[0]
            if (g.members.length === 1 && n !== undefined)
                builder.nodeMsg(getResolvedNode(n))
            units.push(builder.build())
            return
        }
        if (g.filters.length === 0) {
            const items = g.members.map((c: Readonly<Candidate>): PanelUnit =>
                new PanelUnitBuilder().parts(c.view).entity(c).build())
            units.push(...items)
            return
        }
        const lastFilter = g.filters[g.filters.length - 1]
        const parent = new PanelUnitBuilder()
            .parts([new ViewPartBuilder()
                .content(lastFilter.value)
                // (TODO: yiliang) Correct the match map.
                .matchedMap(new Map<number, number>())
                .type(ViewType.UNKNOWN)
                .build()])
            .entity(g.filters)
            .build()
        units.push(parent)
    })
    return units
}
