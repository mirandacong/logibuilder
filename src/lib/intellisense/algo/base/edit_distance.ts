type MatchInfo = readonly [string, Map<number, number>]

/**
 * Get the recommended words according to the edit distance between 2 words.
 *
 * We set the threshold = 0.5, which limits the maximum edit distance of
 * recommended words.
 * For example, pattern = 'abc' and beMatched1 = 'def'.
 * The edit distance is 3
 * and it exceeds the maximum which is 1.5(pattern.length * threshold).
 * Therefore, beMatched1 will not be recommended.
 */
export function editDistMatch(
    pattern: string,
    beMatched: readonly string[],
    caseSensitive = true,
): readonly MatchInfo[] {
    const threshold = 0.5
    const result: MatchInfo[] = []
    // tslint:disable-next-line: no-loop
    for (const word of beMatched) {
        const target = caseSensitive ? pattern : pattern.toLowerCase()
        const candidateWord = caseSensitive ? word : word.toLowerCase()
        const matrix: readonly(readonly number[])[] =
            getEditDistMatrix(target, candidateWord)
        const editDist: number = matrix[target.length][candidateWord.length]
        if (editDist > target.length * threshold)
            continue
        const wordIndex = backTrackEditDist(matrix, target, candidateWord)
        const hint = [word, wordIndex] as MatchInfo
        result.push(hint)
    }

    return result
}

/**
 * Get the edit distance of s1 and s2.
 */
export function getEditDist(s1: string, s2: string): number {
    return getEditDistMatrix(s1, s2)[s1.length][s2.length]
}

/**
 * Get the edit distance matrix between s1 and s2.
 *
 * For more: https://en.wikipedia.org/wiki/Edit_distance
 */
function getEditDistMatrix(
    s1: string,
    s2: string,
): readonly (readonly number[])[] {
    const l1: number = s1.length
    const l2: number = s2.length
    const inf: number = l1 + l2
    const editDist: number[][] = []
    for (let i = 0; i <= l1; i += 1) {
        editDist.push([])
        // tslint:disable-next-line: no-loop-statement
        for (let j = 0; j <= l2; j += 1)
            editDist[i].push(inf)
    }
    // tslint:disable-next-line: no-loop-statement
    for (let i = 0; i <= l1; i += 1)
        editDist[i][0] = i
    // tslint:disable-next-line: no-loop-statement
    for (let j = 0; j <= l2; j += 1)
        editDist[0][j] = j

    for (let i = 1; i <= l1; i += 1)
        // tslint:disable-next-line: no-loop-statement
        for (let j = 1; j <= l2; j += 1) {
            let flag = 1
            if (s1[i - 1] === s2[j - 1])
                flag = 0
            editDist[i][j] = Math.min(
                editDist[i - 1][j] + 1, editDist[i][j - 1] + 1,
                editDist[i - 1][j - 1] + flag,
            )
        }

    return editDist
}

/**
 * This function used to back track the matrix generated by getEditDistMatrix.
 *
 * During the back track, we could find the matched characters.
 */
function backTrackEditDist(
    matrix: readonly (readonly number[])[],
    s1: string,
    s2: string,
): Map<number, number> {
    const s2Index = new Map<number, number>()
    let i = s1.length
    let j = s2.length
    const inf = i + j
    if (matrix[i][j] === inf)
        return s2Index
    // tslint:disable-next-line: no-loop-statement
    while (i >= 1 && j >= 1) {
        let flag = 1
        if (s1[i - 1] === s2[j - 1]) {
            s2Index.set(i - 1, j - 1)
            flag = 0
        }
        if (matrix[i - 1][j - 1] + flag < matrix[i - 1][j] + 1 &&
                matrix[i - 1][j - 1] + flag < matrix[i][j - 1] + 1) {
            i -= 1
            j -= 1
        } else if (matrix[i][j - 1] + 1 <= matrix[i - 1][j - 1] + flag &&
                matrix[i][j - 1] <= matrix[i - 1][j])
            j -= 1
        else
            i -= 1
    }

    return s2Index
}
